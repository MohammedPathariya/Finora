The Updated Finora Project Roadmap


‚úÖ Phase 1: Core Product Foundation & MVP (Completed)
This phase represents all the work you have successfully completed to date. You have built a feature-complete and highly functional application that significantly exceeds the initial MVP goals.

Backend: A robust Flask backend with a clean, service-oriented architecture is complete. It features an intelligent, multi-factor recommendation engine, a sophisticated Monte Carlo simulation for projections, and a highly efficient data pipeline using Supabase as a persistent cache.

Frontend: A polished React (TypeScript) single-page application is fully functional. It includes a custom UI component library built upon accessible Radix UI primitives, a well-designed multi-step onboarding wizard, and a data-rich dashboard that is fully integrated with all backend services.

Current State: The Finora application is a demonstrable success in a local development environment, proving the viability of the core concept and technology stack.









üöÄ Phase 2: Foundational Hardening & Architectural Refactoring
Goal: Address critical technical debt and improve the core maintainability of the application before scaling up data or features.

Tasks:

Implement Frontend Routing: Replace the useState-based navigation with React Router for a more scalable and robust user experience.

Externalize Configuration: Remove hardcoded API URLs and manage them with environment variables.

Containerize the Backend: Create a Dockerfile for the Flask application to ensure a consistent and reproducible environment.

Improve Code Documentation: Add detailed docstrings and comments to explain complex logic, especially in the recommendation engine.

NEW ‚Äî ETF Universe Management: Create a dedicated script or simple admin process to manage the list of ETFs in the Supabase etfs table. This makes it easy to add, remove, or update the securities the application tracks without manual database edits, preparing for the expansion in Phase 4.










üìà Phase 3: Testing, Validation, & Automation
Goal: Build a comprehensive, automated testing suite and CI/CD pipeline. This non-negotiable phase ensures that as the application scales in data and complexity, its quality and reliability remain high.

Tasks:

Backend Unit & Integration Testing (pytest): Write tests for all backend services, with a focus on validating financial calculations and edge cases.

Frontend Component & Integration Testing (Jest & RTL): Write tests for the UI library and key user flows like onboarding.

Establish CI/CD Pipeline (GitHub Actions): Create a workflow that automatically runs the entire test suite on every code push, preventing bugs from being merged.










‚ú® Phase 4: Advanced Features & Data Expansion
Goal: With a stable and tested foundation, confidently build new user-facing features and significantly expand the application's data capabilities.

Tasks:

Advanced Data Visualization: Integrate the HistoricalChart component into the MarketDataPage to provide richer, more immediate visual feedback.

Implement Core User Actions: Build the "Download Plan PDF" and "Schedule a Call" features on the dashboard.

NEW ‚Äî Expand ETF Universe: Increase the number of tracked ETFs from ~100 to 500+. Use the management script from Phase 2 to populate the new securities. Profile the backend to ensure performance remains acceptable during recommendation generation with the larger dataset.

NEW ‚Äî Integrate Real-Time Data:

Select and subscribe to a live market data API (e.g., Finnhub, Polygon.io).

Create a new, lean backend endpoint (e.g., /api/prices/live) that fetches real-time quotes from this new provider.

Update the frontend Dashboard and MarketDataPage to periodically call this endpoint, displaying live price updates and more dynamic "YTD Return" calculations. The cached data will still be used for historical charts and initial page loads.










üåç Phase 5: Production Deployment & Automation
Goal: Push the fully-featured, tested, and data-rich application to a live, public URL and automate its maintenance.

Tasks:

Deploy Backend & Frontend: Deploy the containerized backend to Render and the frontend to Vercel, configuring all production environment variables.

NEW ‚Äî Automate Historical Data Collection: Set up a Cron Job (e.g., Render Cron Jobs) to run the populate_historical_data.py script automatically on a daily schedule. This ensures your application's historical data stays fresh without any manual intervention.

Finalize Documentation: Write the comprehensive README.md with a link to the live demo, architecture diagrams, and setup instructions.

Basic Monitoring: Set up uptime monitoring for the live application endpoints.











üîÆ Future Phases (Post-Launch)
After the core ETF product is successfully launched and automated, you can focus on major product expansions.

Asset Class Expansion:

Individual Stocks: Add a new module to the recommendation engine for selecting individual stocks, using different metrics (e.g., P/E ratio, market cap) than those used for ETFs.

Commodities & Alternatives: Integrate data sources for assets like Gold (GLD), Silver (SLV), and Cryptocurrencies (IBIT). This will require adding new "Alternative" categories to the asset allocation models.

Real Estate: Incorporate Real Estate Investment Trusts (REITs) as a distinct asset class within the stock/ETF framework.

User Accounts & Personalization:

Implement user authentication and persistent profiles.

Allow users to save, name, and compare different investment plans.

Track the actual performance of a user's plan over time.